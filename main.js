// Generated by CoffeeScript 1.6.1
var Deferred, fs, path;

fs = require('fs');

path = require('path');

Deferred = require('when');

module.exports = function(scssDir, tmplDir, callback) {
  var readRecursiveDir, readTmplDir, regSelector, selectorsUsed;
  regSelector = new RegExp('(\\.|#)([\\w\\s-_]*?)({|\\s|,)', 'ig');
  selectorsUsed = {};
  readRecursiveDir = function(dir, done) {
    var results;
    results = [];
    return fs.readdir(dir, function(err, list) {
      var pending;
      pending = null;
      if (err) {
        return done(err);
      }
      pending = list.length;
      if (!pending) {
        return done(null, results);
      }
      return list.forEach(function(file) {
        file = "" + dir + "/" + file;
        return fs.stat(file, function(err, stat) {
          if (stat && stat.isDirectory()) {
            return readRecursiveDir(file, function(err, res) {
              results = results.concat(res);
              if (!--pending) {
                return done(null, results);
              }
            });
          } else {
            results.push(file);
            if (!--pending) {
              return done(null, results);
            }
          }
        });
      });
    });
  };
  readTmplDir = function(dirList, callback) {
    var promises, result;
    result = [];
    promises = [];
    if (!Array.isArray(dirList)) {
      dirList = [dirList];
    }
    dirList.forEach(function(dir) {
      var dfd;
      dfd = Deferred.defer();
      promises.push(dfd.promise);
      return readRecursiveDir(dir, function(err, files) {
        if (err) {
          return callback(err);
        } else {
          result = result.concat(files);
          return dfd.resolve();
        }
      });
    });
    return Deferred.all(promises).then(function() {
      return callback(null, result);
    });
  };
  return readRecursiveDir(scssDir, function(err, files) {
    var promises;
    if (err) {
      if (typeof callback === "function") {
        callback(err);
      }
      return;
    }
    promises = [];
    files.forEach(function(file) {
      var dfd, filePath;
      filePath = path.resolve(scssDir, file);
      if (!fs.lstatSync(filePath).isDirectory()) {
        dfd = Deferred.defer();
        promises.push(dfd.promise);
        return fs.readFile(filePath, function(err, content) {
          var scss, selectors;
          scss = content.toString();
          selectors = scss.match(regSelector);
          if (Array.isArray(selectors)) {
            selectors.forEach(function(selector) {
              selector = selector.replace(/\.|#|,|{/ig, '').trim();
              if (selector && isNaN(parseInt(selector)) && (!selector.match(/^[\w\d]*$/) || selector.length !== 6)) {
                return selectorsUsed[selector] = {
                  file: filePath,
                  usedCount: 0
                };
              }
            });
          }
          return dfd.resolve();
        });
      }
    });
    return Deferred.all(promises).then(function() {
      promises = [];
      return readTmplDir(tmplDir, function(err, files) {
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        files.forEach(function(file) {
          var dfd;
          dfd = Deferred.defer();
          promises.push(dfd.promise);
          return fs.readFile(file, function(err, content) {
            var selector, selectorItem, tmpl;
            tmpl = content.toString();
            for (selector in selectorsUsed) {
              selectorItem = selectorsUsed[selector];
              if (tmpl.indexOf(selector) !== -1) {
                selectorItem.usedCount++;
              }
            }
            return dfd.resolve();
          });
        });
        return Deferred.all(promises).then(function() {
          var selector, selectorItem;
          for (selector in selectorsUsed) {
            selectorItem = selectorsUsed[selector];
            if (selectorItem.usedCount === 0) {
              console.log("" + selector + "\n" + selectorItem.file + "\n======================");
            }
          }
          return typeof callback === "function" ? callback() : void 0;
        });
      });
    });
  });
};
